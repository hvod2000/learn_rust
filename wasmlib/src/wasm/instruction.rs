use std::io::{Error, Result};

use super::leb128::{Reader, Writer};
use super::DataType;

#[derive(Clone, PartialEq)]
#[allow(non_camel_case_types)]
pub enum Instr {
	unreachable,
	nop,
	block(Option<DataType>, Vec<Instr>),
	looped(Option<DataType>, Vec<Instr>),
	if_else(Option<DataType>, Vec<Instr>, Vec<Instr>),
	br(usize),
	br_if(usize),
	br_table(Vec<usize>),
	return_result,
	call(usize),
	call_indirect(usize, usize),
	drop,
	select,
	local_get(u32),
	local_set(u32),
	local_tee(u32),
	global_get(u32),
	global_set(u32),
	i32_load(u32, u32),
	i64_load(u32, u32),
	f32_load(u32, u32),
	f64_load(u32, u32),
	i32_load8_s(u32, u32),
	i32_load8_u(u32, u32),
	i32_load16_s(u32, u32),
	i32_load16_u(u32, u32),
	i64_load8_s(u32, u32),
	i64_load8_u(u32, u32),
	i64_load16_s(u32, u32),
	i64_load16_u(u32, u32),
	i64_load32_s(u32, u32),
	i64_load32_u(u32, u32),
	i32_store(u32, u32),
	i64_store(u32, u32),
	f32_store(u32, u32),
	f64_store(u32, u32),
	i32_store8(u32, u32),
	i32_store16(u32, u32),
	i64_store8(u32, u32),
	i64_store16(u32, u32),
	i64_store32(u32, u32),
	memory_size,
	memory_grow,
	i32_const(i32),
	i64_const(i64),
	f32_const(f32),
	f64_const(f64),
	i32_eqz,
	i32_eq,
	i32_ne,
	i32_lt_s,
	i32_lt_u,
	i32_gt_s,
	i32_gt_u,
	i32_le_s,
	i32_le_u,
	i32_ge_s,
	i32_ge_u,
	i64_eqz,
	i64_eq,
	i64_ne,
	i64_lt_s,
	i64_lt_u,
	i64_gt_s,
	i64_gt_u,
	i64_le_s,
	i64_le_u,
	i64_ge_s,
	i64_ge_u,
	f32_eq,
	f32_ne,
	f32_lt,
	f32_gt,
	f32_le,
	f32_ge,
	f64_eq,
	f64_ne,
	f64_lt,
	f64_gt,
	f64_le,
	f64_ge,
	i32_clz,
	i32_ctz,
	i32_popcnt,
	i32_add,
	i32_sub,
	i32_mul,
	i32_div_s,
	i32_div_u,
	i32_rem_s,
	i32_rem_u,
	i32_and,
	i32_or,
	i32_xor,
	i32_shl,
	i32_shr_s,
	i32_shr_u,
	i32_rotl,
	i32_rotr,
	i64_clz,
	i64_ctz,
	i64_popcnt,
	i64_add,
	i64_sub,
	i64_mul,
	i64_div_s,
	i64_div_u,
	i64_rem_s,
	i64_rem_u,
	i64_and,
	i64_or,
	i64_xor,
	i64_shl,
	i64_shr_s,
	i64_shr_u,
	i64_rotl,
	i64_rotr,
	f32_abs,
	f32_neg,
	f32_ceil,
	f32_floor,
	f32_trunc,
	f32_nearest,
	f32_sqrt,
	f32_add,
	f32_sub,
	f32_mul,
	f32_div,
	f32_min,
	f32_max,
	f32_copysign,
	f64_abs,
	f64_neg,
	f64_ceil,
	f64_floor,
	f64_trunc,
	f64_nearest,
	f64_sqrt,
	f64_add,
	f64_sub,
	f64_mul,
	f64_div,
	f64_min,
	f64_max,
	f64_copysign,
	i32_wrap_i64,
	i32_trunc_f32_s,
	i32_trunc_f32_u,
	i32_trunc_f64_s,
	i32_trunc_f64_u,
	i64_extend_i32_s,
	i64_extend_i32_u,
	i64_trunc_f32_s,
	i64_trunc_f32_u,
	i64_trunc_f64_s,
	i64_trunc_f64_u,
	f32_convert_i32_s,
	f32_convert_i32_u,
	f32_convert_i64_s,
	f32_convert_i64_u,
	f32_demote_f64,
	f64_convert_i32_s,
	f64_convert_i32_u,
	f64_convert_i64_s,
	f64_convert_i64_u,
	f64_promote_f32,
	i32_reinterpret_f32,
	i64_reinterpret_f64,
	f32_reinterpret_i32,
	f64_reinterpret_i64,
	i32_extend8_s,
	i32_extend16_s,
	i64_extend8_s,
	i64_extend16_s,
	i64_extend32_s,
	i32_trunc_sat_f32_s,
	i32_trunc_sat_f32_u,
	i32_trunc_sat_f64_s,
	i32_trunc_sat_f64_u,
	i64_trunc_sat_f32_s,
	i64_trunc_sat_f32_u,
	i64_trunc_sat_f64_s,
	i64_trunc_sat_f64_u,
	end,
	then_end,
}

impl Instr {
	pub fn read_from<R: std::io::Read>(reader: &mut R) -> Result<Self> {
		let err = |x: u8| Err(Error::other(format!("Unsupported opcode: {}", x)));
		use Instr::*;
		Ok(match reader.u8()? {
			0x00 => unreachable,
			0x01 => nop,
			0x02 => block(DataType::from(reader.u8()?), Instr::read_block_from(reader)?.0),
			0x03 => looped(DataType::from(reader.u8()?), Instr::read_block_from(reader)?.0),
			0x04 => {
				let typ = DataType::from(reader.u8()?);
				let blck = Instr::read_block_from(reader)?;
				let otherwise = if blck.1 { vec![] } else { Instr::read_block_from(reader)?.0 };
				if_else(typ, blck.0, otherwise)
			}
			0x05 => then_end,
			0x0B => end,
			0x0C => br(reader.u32()? as usize),
			0x0D => br_if(reader.u32()? as usize),
			0x0E => {
				let size = reader.u32()? as usize;
				let mut labels = vec![0usize; size + 1];
				for i in 0..=size {
					labels[i] = reader.u32()? as usize;
				}
				br_table(labels)
			}
			0x0F => return_result,
			0x10 => call(reader.u32()? as usize),
			0x11 => call_indirect(reader.u32()? as usize, reader.u32()? as usize),
			0x1A => drop,
			0x1B => select,
			0x20 => local_get(reader.u32()?),
			0x21 => local_set(reader.u32()?),
			0x22 => local_tee(reader.u32()?),
			0x23 => global_get(reader.u32()?),
			0x24 => global_set(reader.u32()?),
			0x28 => i32_load(reader.u32()?, reader.u32()?),
			0x29 => i64_load(reader.u32()?, reader.u32()?),
			0x2A => f32_load(reader.u32()?, reader.u32()?),
			0x2B => f64_load(reader.u32()?, reader.u32()?),
			0x2C => i32_load8_s(reader.u32()?, reader.u32()?),
			0x2D => i32_load8_u(reader.u32()?, reader.u32()?),
			0x2E => i32_load16_s(reader.u32()?, reader.u32()?),
			0x2F => i32_load16_u(reader.u32()?, reader.u32()?),
			0x30 => i64_load8_s(reader.u32()?, reader.u32()?),
			0x31 => i64_load8_u(reader.u32()?, reader.u32()?),
			0x32 => i64_load16_s(reader.u32()?, reader.u32()?),
			0x33 => i64_load16_u(reader.u32()?, reader.u32()?),
			0x34 => i64_load32_s(reader.u32()?, reader.u32()?),
			0x35 => i64_load32_u(reader.u32()?, reader.u32()?),
			0x36 => i32_store(reader.u32()?, reader.u32()?),
			0x37 => i64_store(reader.u32()?, reader.u32()?),
			0x38 => f32_store(reader.u32()?, reader.u32()?),
			0x39 => f64_store(reader.u32()?, reader.u32()?),
			0x3A => i32_store8(reader.u32()?, reader.u32()?),
			0x3B => i32_store16(reader.u32()?, reader.u32()?),
			0x3C => i64_store8(reader.u32()?, reader.u32()?),
			0x3D => i64_store16(reader.u32()?, reader.u32()?),
			0x3E => i64_store32(reader.u32()?, reader.u32()?),
			0x3F => match reader.u8()? {
				0x00 => memory_size,
				unknown_opcode => return err(unknown_opcode),
			},
			0x40 => match reader.u8()? {
				0x00 => memory_grow,
				unknown_opcode => return err(unknown_opcode),
			},
			0x41 => i32_const(reader.i32()?),
			0x42 => i64_const(reader.i64()?),
			0x43 => f32_const(reader.f32()?),
			0x44 => f64_const(reader.f64()?),
			0x45 => i32_eqz,
			0x46 => i32_eq,
			0x47 => i32_ne,
			0x48 => i32_lt_s,
			0x49 => i32_lt_u,
			0x4A => i32_gt_s,
			0x4B => i32_gt_u,
			0x4C => i32_le_s,
			0x4D => i32_le_u,
			0x4E => i32_ge_s,
			0x4F => i32_ge_u,
			0x50 => i64_eqz,
			0x51 => i64_eq,
			0x52 => i64_ne,
			0x53 => i64_lt_s,
			0x54 => i64_lt_u,
			0x55 => i64_gt_s,
			0x56 => i64_gt_u,
			0x57 => i64_le_s,
			0x58 => i64_le_u,
			0x59 => i64_ge_s,
			0x5A => i64_ge_u,
			0x5B => f32_eq,
			0x5C => f32_ne,
			0x5D => f32_lt,
			0x5E => f32_gt,
			0x5F => f32_le,
			0x60 => f32_ge,
			0x61 => f64_eq,
			0x62 => f64_ne,
			0x63 => f64_lt,
			0x64 => f64_gt,
			0x65 => f64_le,
			0x66 => f64_ge,
			0x67 => i32_clz,
			0x68 => i32_ctz,
			0x69 => i32_popcnt,
			0x6A => i32_add,
			0x6B => i32_sub,
			0x6C => i32_mul,
			0x6D => i32_div_s,
			0x6E => i32_div_u,
			0x6F => i32_rem_s,
			0x70 => i32_rem_u,
			0x71 => i32_and,
			0x72 => i32_or,
			0x73 => i32_xor,
			0x74 => i32_shl,
			0x75 => i32_shr_s,
			0x76 => i32_shr_u,
			0x77 => i32_rotl,
			0x78 => i32_rotr,
			0x79 => i64_clz,
			0x7A => i64_ctz,
			0x7B => i64_popcnt,
			0x7C => i64_add,
			0x7D => i64_sub,
			0x7E => i64_mul,
			0x7F => i64_div_s,
			0x80 => i64_div_u,
			0x81 => i64_rem_s,
			0x82 => i64_rem_u,
			0x83 => i64_and,
			0x84 => i64_or,
			0x85 => i64_xor,
			0x86 => i64_shl,
			0x87 => i64_shr_s,
			0x88 => i64_shr_u,
			0x89 => i64_rotl,
			0x8A => i64_rotr,
			0x8B => f32_abs,
			0x8C => f32_neg,
			0x8D => f32_ceil,
			0x8E => f32_floor,
			0x8F => f32_trunc,
			0x90 => f32_nearest,
			0x91 => f32_sqrt,
			0x92 => f32_add,
			0x93 => f32_sub,
			0x94 => f32_mul,
			0x95 => f32_div,
			0x96 => f32_min,
			0x97 => f32_max,
			0x98 => f32_copysign,
			0x99 => f64_abs,
			0x9A => f64_neg,
			0x9B => f64_ceil,
			0x9C => f64_floor,
			0x9D => f64_trunc,
			0x9E => f64_nearest,
			0x9F => f64_sqrt,
			0xA0 => f64_add,
			0xA1 => f64_sub,
			0xA2 => f64_mul,
			0xA3 => f64_div,
			0xA4 => f64_min,
			0xA5 => f64_max,
			0xA6 => f64_copysign,
			0xA7 => i32_wrap_i64,
			0xA8 => i32_trunc_f32_s,
			0xA9 => i32_trunc_f32_u,
			0xAA => i32_trunc_f64_s,
			0xAB => i32_trunc_f64_u,
			0xAC => i64_extend_i32_s,
			0xAD => i64_extend_i32_u,
			0xAE => i64_trunc_f32_s,
			0xAF => i64_trunc_f32_u,
			0xB0 => i64_trunc_f64_s,
			0xB1 => i64_trunc_f64_u,
			0xB2 => f32_convert_i32_s,
			0xB3 => f32_convert_i32_u,
			0xB4 => f32_convert_i64_s,
			0xB5 => f32_convert_i64_u,
			0xB6 => f32_demote_f64,
			0xB7 => f64_convert_i32_s,
			0xB8 => f64_convert_i32_u,
			0xB9 => f64_convert_i64_s,
			0xBA => f64_convert_i64_u,
			0xBB => f64_promote_f32,
			0xBC => i32_reinterpret_f32,
			0xBD => i64_reinterpret_f64,
			0xBE => f32_reinterpret_i32,
			0xBF => f64_reinterpret_i64,
			0xC0 => i32_extend8_s,
			0xC1 => i32_extend16_s,
			0xC2 => i64_extend8_s,
			0xC3 => i64_extend16_s,
			0xC4 => i64_extend32_s,
			0xFC => match reader.u8()? {
				0x00 => i32_trunc_sat_f32_s,
				0x01 => i32_trunc_sat_f32_u,
				0x02 => i32_trunc_sat_f64_s,
				0x03 => i32_trunc_sat_f64_u,
				0x04 => i64_trunc_sat_f32_s,
				0x05 => i64_trunc_sat_f32_u,
				0x06 => i64_trunc_sat_f64_s,
				0x07 => i64_trunc_sat_f64_u,
				unknown_opcode => return err(unknown_opcode),
			},
			unknown_opcode => return err(unknown_opcode),
		})
	}

	pub fn read_block_from<R: std::io::Read>(reader: &mut R) -> Result<(Vec<Self>, bool)> {
		let mut instructions = vec![];
		loop {
			match Instr::read_from(reader)? {
				Instr::then_end => return Ok((instructions, true)),
				Instr::end => return Ok((instructions, false)),
				instr => instructions.push(instr),
			}
		}
	}
}
